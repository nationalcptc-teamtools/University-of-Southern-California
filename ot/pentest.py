#!/usr/bin/env python3
"""
OT Pentesting Master Script
===========================

This script provides a comprehensive menu-driven interface for fundamental
OT pentesting operations, orchestrating all OT security tools.

Author: USC-CPTC
Version: 1.0
"""

import argparse
import json
import sys
import os
import subprocess
import time
from datetime import datetime
import logging
from pathlib import Path

class OTPentestMaster:
    def __init__(self):
        """Initialize the OT Pentesting Master"""
        self.results_dir = "ot_pentest_results"
        self.timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # Setup logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(f'ot_pentest_{self.timestamp}.log'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
        
        # Create results directory
        os.makedirs(self.results_dir, exist_ok=True)
        
        # OT Pentesting categories
        self.pentest_categories = {
            '1': {
                'name': 'Network Discovery & Segmentation',
                'description': 'Discover OT networks and verify segmentation',
                'tools': [
                    {
                        'name': 'Network Segmentation Verification',
                        'script': 'segmentation.py',
                        'description': 'Verify network isolation between OT systems',
                        'command': 'python3 segmentation.py --networks "192.168.10.0/24,192.168.20.0/24,192.168.30.0/24" --threads 50'
                    },
                    {
                        'name': 'OT Device Discovery',
                        'script': 'vulnscan.py',
                        'description': 'Discover and classify OT devices',
                        'command': 'python3 vulnscan.py --scan-all --exclude-safety'
                    }
                ]
            },
            '2': {
                'name': 'Vulnerability Assessment',
                'description': 'Assess vulnerabilities in OT systems',
                'tools': [
                    {
                        'name': 'OT Vulnerability Scan',
                        'script': 'vulnscan.py',
                        'description': 'Comprehensive vulnerability assessment',
                        'command': 'python3 vulnscan.py --scan-all --verbose'
                    },
                    {
                        'name': 'Update Pipeline Security',
                        'script': 'updates.py',
                        'description': 'Validate update pipeline security',
                        'command': 'python3 updates.py --validate-all'
                    }
                ]
            },
            '3': {
                'name': 'Access Control & Privileges',
                'description': 'Test access controls and privilege management',
                'tools': [
                    {
                        'name': 'RBAC Audit',
                        'script': 'rbac.ps1',
                        'description': 'Audit role-based access controls',
                        'command': 'powershell -ExecutionPolicy Bypass -File rbac.ps1 -Verbose'
                    },
                    {
                        'name': 'Privilege Activity Monitor',
                        'script': 'privileges.py',
                        'description': 'Monitor privileged account activities',
                        'command': 'python3 privileges.py --start-monitoring --duration 300'
                    }
                ]
            },
            '4': {
                'name': 'Social Engineering & Phishing',
                'description': 'Test social engineering resilience',
                'tools': [
                    {
                        'name': 'Spear-Phishing Simulation',
                        'script': 'phishing.py',
                        'description': 'Simulate spear-phishing attacks',
                        'command': 'python3 phishing.py --create-templates --test-mode'
                    }
                ]
            },
            '5': {
                'name': 'Monitoring & Anomaly Detection',
                'description': 'Monitor OT systems for anomalies',
                'tools': [
                    {
                        'name': 'Telemetry Monitoring',
                        'script': 'telemetry.py',
                        'description': 'Monitor telemetry for command spoofing',
                        'command': 'python3 telemetry.py --simulate --systems navigation,engine,safety'
                    },
                    {
                        'name': 'Privilege Activity Analysis',
                        'script': 'privileges.py',
                        'description': 'Analyze privileged account activities',
                        'command': 'python3 privileges.py --forensic-report --days 7'
                    }
                ]
            },
            '6': {
                'name': 'Compliance & Standards',
                'description': 'Verify compliance with maritime standards',
                'tools': [
                    {
                        'name': 'Maritime Compliance Check',
                        'script': 'compliance.py',
                        'description': 'Check compliance with maritime standards',
                        'command': 'python3 compliance.py --check-all --detailed'
                    }
                ]
            },
            '7': {
                'name': 'Comprehensive OT Assessment',
                'description': 'Run complete OT security assessment',
                'tools': [
                    {
                        'name': 'Full OT Security Assessment',
                        'script': 'all',
                        'description': 'Execute all OT security tests',
                        'command': 'comprehensive_assessment'
                    }
                ]
            }
        }
        
        # Quick assessment templates
        self.quick_assessments = {
            '1': {
                'name': 'Critical Systems Assessment',
                'description': 'Focus on safety-critical and navigation systems',
                'tools': ['segmentation.py', 'vulnscan.py', 'compliance.py']
            },
            '2': {
                'name': 'Network Security Assessment',
                'description': 'Focus on network segmentation and connectivity',
                'tools': ['segmentation.py', 'vulnscan.py', 'privileges.py']
            },
            '3': {
                'name': 'Access Control Assessment',
                'description': 'Focus on authentication and authorization',
                'tools': ['rbac.ps1', 'privileges.py', 'phishing.py']
            },
            '4': {
                'name': 'Compliance Assessment',
                'description': 'Focus on maritime standards compliance',
                'tools': ['compliance.py', 'updates.py', 'telemetry.py']
            }
        }
    
    def display_main_menu(self):
        """Display the main pentesting menu"""
        print("\n" + "="*80)
        print("ðŸš¢ OT PENTESTING MASTER - MARITIME CYBERSECURITY ASSESSMENT")
        print("="*80)
        print("Select a pentesting category:")
        print()
        
        for key, category in self.pentest_categories.items():
            print(f"  {key}. {category['name']}")
            print(f"     {category['description']}")
            print()
        
        print("  Q. Quick Assessment Templates")
        print("  R. View Results")
        print("  H. Help")
        print("  X. Exit")
        print("="*80)
    
    def display_quick_assessments(self):
        """Display quick assessment templates"""
        print("\n" + "="*60)
        print("QUICK ASSESSMENT TEMPLATES")
        print("="*60)
        print("Select a quick assessment:")
        print()
        
        for key, assessment in self.quick_assessments.items():
            print(f"  {key}. {assessment['name']}")
            print(f"     {assessment['description']}")
            print()
        
        print("  B. Back to Main Menu")
        print("="*60)
    
    def display_category_tools(self, category_key):
        """Display tools for a specific category"""
        category = self.pentest_categories[category_key]
        
        print(f"\n" + "="*60)
        print(f"TOOLS: {category['name'].upper()}")
        print("="*60)
        print(f"Description: {category['description']}")
        print()
        print("Available tools:")
        print()
        
        for i, tool in enumerate(category['tools'], 1):
            print(f"  {i}. {tool['name']}")
            print(f"     {tool['description']}")
            print()
        
        print("  A. Run All Tools in Category")
        print("  B. Back to Main Menu")
        print("="*60)
    
    def run_tool(self, tool, category_name):
        """Run a specific tool"""
        print(f"\n[*] Running: {tool['name']}")
        print(f"[*] Category: {category_name}")
        print(f"[*] Description: {tool['description']}")
        print(f"[*] Command: {tool['command']}")
        print("-" * 60)
        
        try:
            # Create output filename
            output_file = f"{self.results_dir}/{tool['script'].replace('.py', '').replace('.ps1', '')}_{self.timestamp}.json"
            
            # Modify command to include output file
            if tool['script'] != 'all':
                if 'python3' in tool['command']:
                    tool['command'] += f" --output {output_file}"
                elif 'powershell' in tool['command']:
                    tool['command'] += f" -OutputFile {output_file}"
            
            # Execute the command
            self.logger.info(f"Executing: {tool['command']}")
            result = subprocess.run(
                tool['command'],
                shell=True,
                capture_output=True,
                text=True,
                timeout=300  # 5 minute timeout
            )
            
            if result.returncode == 0:
                print(f"[âœ“] {tool['name']} completed successfully")
                if result.stdout:
                    print("Output:")
                    print(result.stdout[:500] + "..." if len(result.stdout) > 500 else result.stdout)
            else:
                print(f"[âœ—] {tool['name']} failed with return code {result.returncode}")
                if result.stderr:
                    print("Error:")
                    print(result.stderr[:500] + "..." if len(result.stderr) > 500 else result.stderr)
            
            # Save execution log
            self._save_execution_log(tool, result, output_file)
            
        except subprocess.TimeoutExpired:
            print(f"[âœ—] {tool['name']} timed out after 5 minutes")
        except Exception as e:
            print(f"[âœ—] Error running {tool['name']}: {e}")
            self.logger.error(f"Error running {tool['name']}: {e}")
    
    def run_category_tools(self, category_key):
        """Run all tools in a category"""
        category = self.pentest_categories[category_key]
        
        print(f"\n[*] Running all tools in category: {category['name']}")
        print("="*60)
        
        for tool in category['tools']:
            self.run_tool(tool, category['name'])
            print()
            time.sleep(2)  # Brief pause between tools
        
        print(f"[âœ“] Completed all tools in category: {category['name']}")
    
    def run_quick_assessment(self, assessment_key):
        """Run a quick assessment template"""
        assessment = self.quick_assessments[assessment_key]
        
        print(f"\n[*] Running Quick Assessment: {assessment['name']}")
        print(f"[*] Description: {assessment['description']}")
        print("="*60)
        
        for tool_script in assessment['tools']:
            # Find the tool in categories
            tool = self._find_tool_by_script(tool_script)
            if tool:
                self.run_tool(tool, "Quick Assessment")
                print()
                time.sleep(2)
        
        print(f"[âœ“] Completed Quick Assessment: {assessment['name']}")
    
    def _find_tool_by_script(self, script_name):
        """Find a tool by its script name"""
        for category in self.pentest_categories.values():
            for tool in category['tools']:
                if tool['script'] == script_name:
                    return tool
        return None
    
    def run_comprehensive_assessment(self):
        """Run comprehensive OT security assessment"""
        print("\n[*] Starting Comprehensive OT Security Assessment")
        print("="*60)
        print("This will run all available OT security tools...")
        print()
        
        # Run all categories in order
        categories_to_run = ['1', '2', '3', '4', '5', '6']
        
        for category_key in categories_to_run:
            category = self.pentest_categories[category_key]
            print(f"\n[*] Category: {category['name']}")
            print("-" * 40)
            
            for tool in category['tools']:
                self.run_tool(tool, category['name'])
                print()
                time.sleep(3)  # Pause between tools
        
        print("\n[âœ“] Comprehensive OT Security Assessment Completed!")
        self._generate_assessment_summary()
    
    def _save_execution_log(self, tool, result, output_file):
        """Save execution log for a tool"""
        log_entry = {
            'timestamp': datetime.now().isoformat(),
            'tool_name': tool['name'],
            'script': tool['script'],
            'command': tool['command'],
            'return_code': result.returncode,
            'stdout': result.stdout,
            'stderr': result.stderr,
            'output_file': output_file
        }
        
        log_file = f"{self.results_dir}/execution_log_{self.timestamp}.json"
        
        # Load existing log or create new
        if os.path.exists(log_file):
            with open(log_file, 'r') as f:
                logs = json.load(f)
        else:
            logs = []
        
        logs.append(log_entry)
        
        with open(log_file, 'w') as f:
            json.dump(logs, f, indent=2)
    
    def _generate_assessment_summary(self):
        """Generate assessment summary"""
        summary = {
            'assessment_timestamp': datetime.now().isoformat(),
            'assessment_type': 'Comprehensive OT Security Assessment',
            'results_directory': self.results_dir,
            'tools_executed': [],
            'summary': {
                'total_tools': 0,
                'successful_tools': 0,
                'failed_tools': 0
            }
        }
        
        # Count results
        log_file = f"{self.results_dir}/execution_log_{self.timestamp}.json"
        if os.path.exists(log_file):
            with open(log_file, 'r') as f:
                logs = json.load(f)
            
            summary['tools_executed'] = logs
            summary['summary']['total_tools'] = len(logs)
            summary['summary']['successful_tools'] = len([log for log in logs if log['return_code'] == 0])
            summary['summary']['failed_tools'] = len([log for log in logs if log['return_code'] != 0])
        
        # Save summary
        summary_file = f"{self.results_dir}/assessment_summary_{self.timestamp}.json"
        with open(summary_file, 'w') as f:
            json.dump(summary, f, indent=2)
        
        print(f"\n[*] Assessment summary saved to: {summary_file}")
        print(f"[*] Results directory: {self.results_dir}")
    
    def view_results(self):
        """View available results"""
        print("\n" + "="*60)
        print("OT PENTESTING RESULTS")
        print("="*60)
        
        if not os.path.exists(self.results_dir):
            print("No results directory found.")
            return
        
        # List result files
        result_files = []
        for file in os.listdir(self.results_dir):
            if file.endswith('.json'):
                result_files.append(file)
        
        if not result_files:
            print("No result files found.")
            return
        
        print("Available result files:")
        print()
        for i, file in enumerate(sorted(result_files), 1):
            file_path = os.path.join(self.results_dir, file)
            file_size = os.path.getsize(file_path)
            mod_time = datetime.fromtimestamp(os.path.getmtime(file_path))
            print(f"  {i}. {file}")
            print(f"     Size: {file_size} bytes, Modified: {mod_time.strftime('%Y-%m-%d %H:%M:%S')}")
            print()
        
        # Show summary if available
        summary_files = [f for f in result_files if 'summary' in f]
        if summary_files:
            print("Assessment Summary:")
            latest_summary = sorted(summary_files)[-1]
            summary_path = os.path.join(self.results_dir, latest_summary)
            
            try:
                with open(summary_path, 'r') as f:
                    summary = json.load(f)
                
                print(f"  Assessment Type: {summary.get('assessment_type', 'Unknown')}")
                print(f"  Total Tools: {summary['summary']['total_tools']}")
                print(f"  Successful: {summary['summary']['successful_tools']}")
                print(f"  Failed: {summary['summary']['failed_tools']}")
            except Exception as e:
                print(f"  Error reading summary: {e}")
    
    def show_help(self):
        """Show help information"""
        print("\n" + "="*80)
        print("OT PENTESTING MASTER - HELP")
        print("="*80)
        print()
        print("This tool provides a comprehensive interface for OT security testing.")
        print("It orchestrates multiple specialized tools for maritime OT environments.")
        print()
        print("CATEGORIES:")
        print("  1. Network Discovery & Segmentation - Discover and verify network isolation")
        print("  2. Vulnerability Assessment - Find vulnerabilities in OT systems")
        print("  3. Access Control & Privileges - Test authentication and authorization")
        print("  4. Social Engineering & Phishing - Test human factors")
        print("  5. Monitoring & Anomaly Detection - Monitor for suspicious activities")
        print("  6. Compliance & Standards - Verify maritime standards compliance")
        print("  7. Comprehensive Assessment - Run all tests")
        print()
        print("QUICK ASSESSMENTS:")
        print("  Pre-configured assessment templates for common scenarios")
        print()
        print("RESULTS:")
        print("  All results are saved in JSON format in the 'ot_pentest_results' directory")
        print("  Execution logs track the success/failure of each tool")
        print()
        print("SAFETY:")
        print("  - Always obtain proper authorization before testing")
        print("  - Use test modes when available")
        print("  - Review configurations for your specific environment")
        print("  - Safety-critical systems are excluded from vulnerability scanning")
        print()
        print("For detailed help on individual tools, use:")
        print("  python3 <tool_name>.py --help")
        print("="*80)
    
    def run_interactive_mode(self):
        """Run the interactive menu system"""
        while True:
            self.display_main_menu()
            choice = input("Enter your choice: ").strip().upper()
            
            if choice == 'X':
                print("\n[*] Exiting OT Pentesting Master")
                break
            elif choice == 'H':
                self.show_help()
            elif choice == 'R':
                self.view_results()
            elif choice == 'Q':
                self._handle_quick_assessments()
            elif choice in self.pentest_categories:
                if choice == '7':  # Comprehensive assessment
                    confirm = input("This will run ALL tools. Continue? (y/N): ").strip().lower()
                    if confirm == 'y':
                        self.run_comprehensive_assessment()
                else:
                    self._handle_category_selection(choice)
            else:
                print("\n[!] Invalid choice. Please try again.")
    
    def _handle_quick_assessments(self):
        """Handle quick assessment selection"""
        while True:
            self.display_quick_assessments()
            choice = input("Enter your choice: ").strip()
            
            if choice.upper() == 'B':
                break
            elif choice in self.quick_assessments:
                confirm = input(f"Run {self.quick_assessments[choice]['name']}? (y/N): ").strip().lower()
                if confirm == 'y':
                    self.run_quick_assessment(choice)
                    input("\nPress Enter to continue...")
            else:
                print("\n[!] Invalid choice. Please try again.")
    
    def _handle_category_selection(self, category_key):
        """Handle category tool selection"""
        while True:
            self.display_category_tools(category_key)
            choice = input("Enter your choice: ").strip().upper()
            
            if choice == 'B':
                break
            elif choice == 'A':
                confirm = input(f"Run all tools in {self.pentest_categories[category_key]['name']}? (y/N): ").strip().lower()
                if confirm == 'y':
                    self.run_category_tools(category_key)
                    input("\nPress Enter to continue...")
            elif choice.isdigit():
                tool_index = int(choice) - 1
                category = self.pentest_categories[category_key]
                if 0 <= tool_index < len(category['tools']):
                    tool = category['tools'][tool_index]
                    confirm = input(f"Run {tool['name']}? (y/N): ").strip().lower()
                    if confirm == 'y':
                        self.run_tool(tool, category['name'])
                        input("\nPress Enter to continue...")
                else:
                    print("\n[!] Invalid tool number. Please try again.")
            else:
                print("\n[!] Invalid choice. Please try again.")

def main():
    """Main function"""
    parser = argparse.ArgumentParser(
        description="OT Pentesting Master - Maritime Cybersecurity Assessment Tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python3 pentest.py                    # Interactive mode
  python3 pentest.py --quick 1          # Run Critical Systems Assessment
  python3 pentest.py --category 2       # Run Vulnerability Assessment
  python3 pentest.py --comprehensive    # Run all assessments
  python3 pentest.py --results          # View results
        """
    )
    
    parser.add_argument(
        '--quick',
        type=str,
        choices=['1', '2', '3', '4'],
        help='Run a quick assessment template'
    )
    
    parser.add_argument(
        '--category',
        type=str,
        choices=['1', '2', '3', '4', '5', '6'],
        help='Run all tools in a specific category'
    )
    
    parser.add_argument(
        '--comprehensive',
        action='store_true',
        help='Run comprehensive OT security assessment'
    )
    
    parser.add_argument(
        '--results',
        action='store_true',
        help='View available results'
    )
    
    parser.add_argument(
        '--help-tool',
        action='store_true',
        help='Show detailed help'
    )
    
    args = parser.parse_args()
    
    # Create pentest master instance
    master = OTPentestMaster()
    
    try:
        if args.quick:
            # Run quick assessment
            assessment = master.quick_assessments[args.quick]
            print(f"[*] Running Quick Assessment: {assessment['name']}")
            master.run_quick_assessment(args.quick)
            
        elif args.category:
            # Run category tools
            category = master.pentest_categories[args.category]
            print(f"[*] Running Category: {category['name']}")
            master.run_category_tools(args.category)
            
        elif args.comprehensive:
            # Run comprehensive assessment
            master.run_comprehensive_assessment()
            
        elif args.results:
            # View results
            master.view_results()
            
        elif args.help_tool:
            # Show help
            master.show_help()
            
        else:
            # Interactive mode
            master.run_interactive_mode()
            
    except KeyboardInterrupt:
        print("\n[*] OT Pentesting Master interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n[!] Error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
